<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Piano Keyboard with MIDI Player</title>
    <!-- Use Tone.js for better sound synthesis and MIDI handling -->
    <script src="../Hidden/Script/Tone.js"></script>
    <script src="../Hidden/Script/Midi.js"></script>
    <!-- Use a more reliable VexFlow version -->
    <script src="../Hidden/Script/vexflow.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            position: fixed; /* Prevent body from scrolling */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        body {
            background-color: #f8f9fa;
            touch-action: manipulation;
        }
        
        .main-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent container overflow */
        }
        
        .piano-container {
            width: 100%;
            flex-grow: 1;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            position: relative;
            background: linear-gradient(to bottom, #3e3e3e, #292929);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5) inset;
            transition: height 0.3s ease;
            -webkit-overflow-scrolling: touch;
        }
        
        .score-container {
            width: 100%;
            height: 0;
            overflow: auto;
            position: relative;
            background: #f8f8f5;
            transition: height 0.3s ease;
            display: none;
            -webkit-overflow-scrolling: touch;
        }
        
        .score-container.active {
            height: 50%;
            display: block;
        }
        
        .piano-container.with-score {
            height: 50%;
        }
        
        .piano-frame {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, #825c32, #6a4827);
            border-bottom: 2px solid #543c22;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }
        
        .piano-keys {
            position: relative;
            height: 100%;
            display: inline-block;
            padding-top: 40px; /* Space for the piano frame */
        }
        
        .white-key {
            display: inline-block;
            height: calc(100% - 40px);
            width: 40px;
            background: linear-gradient(to bottom, #f8f8f8, #e6e6e6);
            border: 1px solid #333;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
            vertical-align: top;
            position: relative;
            z-index: 1;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 2px 2px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        
        .white-key::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
            pointer-events: none;
        }
        
        .black-key {
            position: absolute;
            width: 24px;
            height: 65%;
            background: linear-gradient(to bottom, #333, #111);
            z-index: 2;
            top: 40px;
            cursor: pointer;
            transition: all 0.1s ease;
            border-bottom-left-radius: 3px;
            border-bottom-right-radius: 3px;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
            touch-action: none;
        }
        
        .black-key::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30%;
            background: linear-gradient(to bottom, rgba(80, 80, 80, 0.4), rgba(0, 0, 0, 0));
            border-bottom-left-radius: 3px;
            border-bottom-right-radius: 3px;
            pointer-events: none;
        }
        
        .white-key.active {
            background: linear-gradient(to bottom, #BFBEFD, #9493FB);
            transform: translateY(2px);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }
        
        .black-key.active {
            background: linear-gradient(to bottom, #7977E8, #6563D4);
            transform: translateY(2px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .key-label {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 9px;
            color: #666;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
            opacity: 0.8;
        }
        
        .black-key .key-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 8px;
        }
        
        .black-key .sharp-label {
            bottom: 25px;
        }
        
        .black-key .flat-label {
            bottom: 10px;
        }
        
        /* Piano base */
        .piano-base {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 15px;
            background: linear-gradient(to bottom, #825c32, #6a4827);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }
        
        /* Control bar for keyboard range and size */
        .keyboard-controls {
            width: 100%;
            height: 40px;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-label {
            color: white;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .range-slider {
            width: 120px;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: #555;
            outline: none;
            border-radius: 5px;
        }
        
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
        }
        
        .range-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            border: none;
        }
        
        .octave-display {
            color: white;
            font-size: 12px;
            min-width: 40px;
            text-align: center;
        }
        
        /* Timeline scrubber */
        .timeline-container {
            width: 100%;
            height: 40px; /* Fixed height */
            min-height: 40px; /* Ensure minimum height */
            background: #333;
            position: relative;
            display: flex;
            align-items: center;
            padding: 0 15px;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10; /* Ensure it's above other elements */
        }
        
        .timeline-scrubber {
            width: 100%;
            height: 20px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
        }
        
        .timeline-scrubber::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #555;
            border-radius: 3px;
        }
        
        .timeline-scrubber::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        .timeline-scrubber::-webkit-slider-thumb:hover {
            background: #6E6BE8;
        }
        
        .timeline-scrubber::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #555;
            border-radius: 3px;
        }
        
        .timeline-scrubber::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        .timeline-time {
            color: white;
            font-size: 12px;
            padding: 0 10px;
            font-family: monospace;
            min-width: 70px;
        }
        
        /* Sheet music styling */
        .sheet-music {
            width: 100%;
            height: 100%;
            overflow: auto;
            position: relative;
            background: #fff;
            padding: 20px;
        }
        
        .sheet-container {
            margin: 0 auto;
            max-width: 900px;
            position: relative;
        }
        
        .sheet-title {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .playhead {
            position: absolute;
            width: 2px;
            background-color: #5D5CDE;
            z-index: 15;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 3px rgba(93, 92, 222, 0.7);
            top: 0;
            bottom: 0;
        }
        
        .piano-roll-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            position: relative;
            background: #f0f0f0;
        }
        
        .piano-roll {
            position: relative;
            min-height: 500px;
        }
        
        .piano-roll-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 60px;
            height: 100%;
            background: #ddd;
            border-right: 1px solid #aaa;
            z-index: 5;
        }
        
        .piano-roll-main {
            position: absolute;
            left: 60px;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
        }
        
        .piano-roll-note {
            position: absolute;
            background: #5D5CDE;
            border: 1px solid #4a49b8;
            border-radius: 3px;
            cursor: pointer;
            transition: opacity 0.1s;
        }
        
        .piano-roll-note:hover {
            opacity: 0.8;
        }
        
        /* Controls overlay */
        .controls-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.85);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 90%;
            width: auto;
            transition: all 0.3s ease;
            max-height: calc(100% - 120px);
            overflow-y: auto;
        }
        
        .controls-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .playback-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 5px 0;
        }
        
        .control-btn {
            background: linear-gradient(to bottom, #6E6BE8, #5D5CDE);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            touch-action: manipulation;
            min-height: 44px; /* Larger touch target */
            min-width: 44px; /* Larger touch target */
        }
        
        .control-btn:hover {
            background: linear-gradient(to bottom, #7B78F1, #6A69EB);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        
        .control-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .control-btn:disabled {
            background: linear-gradient(to bottom, #9593D9, #8684C7);
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Switch toggle styling */
        .switch-toggle {
            background-color: #444;
            border-radius: 20px;
            padding: 2px;
            width: 60px;
            height: 30px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s ease;
            touch-action: manipulation;
            min-height: 30px; /* Larger touch target for mobile */
        }
        
        .switch-toggle.active {
            background-color: #5D5CDE;
        }
        
        .switch-toggle-slider {
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background-color: white;
            left: 2px;
            top: 2px;
            transition: left 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        .switch-toggle.active .switch-toggle-slider {
            left: 32px;
        }
        
        .switch-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .switch-label {
            font-size: 14px;
        }
        
        .file-info {
            text-align: center;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 300;
            letter-spacing: 0.5px;
        }
        
        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top: 4px solid #5D5CDE;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 18px;
            font-weight: 300;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .loading-subtext {
            font-size: 14px;
            opacity: 0.7;
        }
        
        /* Custom file input styling */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            font-size: 16px; /* Prevent zoom on mobile */
        }
        
        .file-input-label {
            background: linear-gradient(to bottom, #6E6BE8, #5D5CDE);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            display: inline-block;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            min-height: 44px; /* Larger touch target */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .file-input-label:hover {
            background: linear-gradient(to bottom, #7B78F1, #6A69EB);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        
        /* Dark mode */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #121212;
            }
            
            .score-container {
                background: #1e1e1e;
            }
            
            .sheet-music {
                background: #222;
                color: #eee;
            }
            
            .sheet-title {
                color: #eee;
            }
            
            .white-key {
                background: linear-gradient(to bottom, #ececec, #d8d8d8);
            }
            
            .key-label {
                color: #555;
            }
            
            .piano-roll-container {
                background: #222;
            }
            
            .piano-roll-sidebar {
                background: #333;
                border-color: #444;
            }
            
            .keyboard-controls {
                background: #222;
            }
            
            .range-slider {
                background: #444;
            }
        }
        
        /* Hide scrollbar but keep functionality */
        .piano-container::-webkit-scrollbar,
        .score-container::-webkit-scrollbar {
            height: 8px; /* Increased height for better usability */
            width: 0;
            background: transparent;
        }
        
        .piano-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        /* Mobile and responsive styles */
        @media (max-width: 768px) {
            .controls-overlay {
                max-width: 96%;
                max-height: 80%;
            }
            
            .controls-row {
                flex-direction: column;
                align-items: center;
            }
            
            .file-upload {
                margin-bottom: 10px;
                width: 100%;
            }
            
            .file-input-wrapper {
                width: 100%;
            }
            
            .file-input-label {
                width: 100%;
                text-align: center;
            }
            
            /* Adjust piano key sizes for mobile */
            .white-key {
                width: 34px; /* Slightly smaller on mobile */
            }
            
            /* Improve touch areas */
            .control-btn {
                padding: 10px 14px;
            }
            
            /* Smaller note labels on mobile instead of hiding them */
            @media (max-width: 480px) {
                .key-label {
                    font-size: 7px;
                    bottom: 5px;
                }
                
                .black-key .key-label {
                    font-size: 6px;
                }
                
                .black-key .sharp-label {
                    bottom: 15px;
                }
                
                .black-key .flat-label {
                    bottom: 5px;
                }
                
                .keyboard-controls {
                    flex-direction: column;
                    height: auto;
                    padding: 10px;
                    gap: 8px;
                }
                
                .range-slider {
                    width: 100px;
                }
            }
        }
        
        /* Controls toggle button */
        .controls-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #5D5CDE;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
        }
        
        /* Error message */
        #error-message {
            position: fixed;
            bottom: 70px; /* Position above the timeline */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            display: none;
        }
        
        /* Ensure bottom area is not obscured */
        .bottom-spacer {
            height: 10px; /* Add extra space at the bottom */
            width: 100%;
            clear: both;
        }
        
        /* Status indicator for audio system */
        .audio-status {
            position: fixed;
            top: 65px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            z-index: 99;
            display: none;
        }
        
        .audio-status.active {
            display: block;
        }
        
        .audio-status.fallback {
            background: rgba(255, 166, 0, 0.8);
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading Piano</div>
        <div class="loading-subtext">Please tap to start audio</div>
    </div>
    
    <div id="error-message"></div>
    <div id="audio-status" class="audio-status">Using Piano Samples</div>
    
    <div class="main-container">
        <div class="keyboard-controls">
            <div class="control-group">
                <span class="control-label">Octave:</span>
                <input type="range" min="0" max="4" value="2" class="range-slider" id="octave-slider">
                <span class="octave-display" id="octave-display">C2-C6</span>
            </div>
            <div class="control-group">
                <span class="control-label">Key Size:</span>
                <input type="range" min="20" max="60" value="40" class="range-slider" id="key-size-slider">
                <span class="octave-display" id="key-size-display">40px</span>
            </div>
        </div>
        
        <div class="piano-container" id="piano-container">
            <div class="piano-frame"></div>
            <div class="piano-keys" id="piano-keys"></div>
            <div class="piano-base"></div>
        </div>
        
        <div class="score-container" id="score-container">
            <div class="sheet-music" id="sheet-music">
                <div class="sheet-container" id="sheet-container">
                    <div class="sheet-title" id="sheet-title">Music Sheet</div>
                    <div id="sheet-notation"></div>
                    <div class="playhead" id="playhead"></div>
                </div>
            </div>
        </div>
        
        <div class="timeline-container">
            <div class="timeline-time" id="current-time">0:00</div>
            <input type="range" min="0" max="100" value="0" class="timeline-scrubber" id="timeline-scrubber">
            <div class="timeline-time" id="total-time">0:00</div>
        </div>
    </div>
    
    <div class="controls-toggle" id="controls-toggle">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12h18M3 6h18M3 18h18"></path>
        </svg>
    </div>
    
    <div class="controls-overlay" id="controls-overlay">
        <div class="controls-row">
            <div class="file-upload">
                <div class="file-input-wrapper">
                    <span class="file-input-label">Choose MIDI File</span>
                    <input type="file" id="midi-upload" accept=".mid,.midi">
                </div>
            </div>
            <div class="switch-container">
                <span class="switch-label">Sheet Music</span>
                <div class="switch-toggle" id="view-toggle">
                    <div class="switch-toggle-slider"></div>
                </div>
            </div>
        </div>
        <div class="playback-controls">
            <button class="control-btn" id="play-btn" disabled="">Play</button>
            <button class="control-btn" id="pause-btn" disabled="">Pause</button>
            <button class="control-btn" id="stop-btn" disabled="">Stop</button>
        </div>
        <div class="file-info" id="file-info">No file loaded</div>
    </div>

    <script>
        // Error handling function
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 5000);
            
            console.error(message);
        }
        
        // Global variables with safety checks for Android
        let Vex = window.Vex || {};
        
        // Piano keyboard data
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Flat names for black keys
        const sharpToFlat = {
            'C#': 'Db',
            'D#': 'Eb',
            'F#': 'Gb',
            'G#': 'Ab',
            'A#': 'Bb'
        };
        
        // Is the note black
        const isBlackKey = {
            'C': false,
            'C#': true,
            'D': false,
            'D#': true,
            'E': false,
            'F': false,
            'F#': true,
            'G': false,
            'G#': true,
            'A': false,
            'A#': true,
            'B': false
        };
        
        // Position of black keys relative to white keys
        const blackKeyPositions = {
            'C#': 0.7, // C# is positioned 70% to the right of C
            'D#': 0.7, // D# is positioned 70% to the right of D
            'F#': 0.7, // F# is positioned 70% to the right of F
            'G#': 0.7, // G# is positioned 70% to the right of G
            'A#': 0.7  // A# is positioned 70% to the right of A
        };
        
        // MIDI playback variables
        let midiFile = null;
        let isPlaying = false;
        let isPaused = false;
        let currentTime = 0;
        let midiData = null;
        let midiPart = null;
        let midiDuration = 0;
        let isAudioInitialized = false;
        let usingFallbackSynth = false;
        
        // Piano roll visualization variables
        let pianoRollWidth = 0;
        let pianoRollContainer = null;
        
        // Keyboard range and size variables
        let startOctave = 2;          // Default starting octave
        let endOctave = 6;            // Default ending octave
        let whiteKeyWidth = 40;       // Default white key width in pixels
        let blackKeyWidthRatio = 0.6; // Black key width as ratio of white key width
        
        // DOM elements
        const pianoContainer = document.getElementById('piano-container');
        const scoreContainer = document.getElementById('score-container');
        const viewToggle = document.getElementById('view-toggle');
        const timelineScrubber = document.getElementById('timeline-scrubber');
        const currentTimeDisplay = document.getElementById('current-time');
        const totalTimeDisplay = document.getElementById('total-time');
        let playhead = document.getElementById('playhead');  // Changed from const to let
        const sheetTitle = document.getElementById('sheet-title');
        const controlsOverlay = document.getElementById('controls-overlay');
        const controlsToggle = document.getElementById('controls-toggle');
        const loadingOverlay = document.getElementById('loading-overlay');
        const octaveSlider = document.getElementById('octave-slider');
        const octaveDisplay = document.getElementById('octave-display');
        const keySizeSlider = document.getElementById('key-size-slider');
        const keySizeDisplay = document.getElementById('key-size-display');
        const audioStatus = document.getElementById('audio-status');
        
        // Toggle controls visibility
        controlsToggle.addEventListener('click', () => {
            controlsOverlay.style.display = controlsOverlay.style.display === 'none' ? 'flex' : 'none';
        });
        
        // Ensure proper display on Android
        function fixAndroidDisplay() {
            // Make sure the app takes the full height of the screen
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            
            // Fix any scroll issues
            document.body.style.height = `${window.innerHeight}px`;
            document.querySelector('.main-container').style.height = `${window.innerHeight}px`;
            
            // Make sure timeline is visible
            document.querySelector('.timeline-container').style.marginBottom = '0';
            
            // Make sure controls are visible
            controlsOverlay.style.display = 'flex';
        }
        
        // Update octave range display
        function updateOctaveDisplay() {
            octaveDisplay.textContent = `C${startOctave}-C${endOctave}`;
        }
        
        // Update key size display
        function updateKeySizeDisplay() {
            keySizeDisplay.textContent = `${whiteKeyWidth}px`;
        }
        
        // Handle octave slider change
        octaveSlider.addEventListener('input', function() {
            startOctave = parseInt(this.value);
            endOctave = startOctave + 4; // Always show a 4-octave range
            updateOctaveDisplay();
            generateKeyboard();
        });
        
        // Handle key size slider change
        keySizeSlider.addEventListener('input', function() {
            whiteKeyWidth = parseInt(this.value);
            updateKeySizeDisplay();
            generateKeyboard();
        });
        
        // Tone.js Sampler for realistic piano sounds
        let pianoSampler = null;
        
        // Initialize Tone.js sampler with piano samples - with fallback for Android
        async function initPiano() {
            try {
                // Create a limiter to prevent distortion
                const limiter = new Tone.Limiter(-3).toDestination();
                
                // Simple reverb for more natural sound with reduced settings
                const reverb = new Tone.Reverb({
                    decay: 1.0,
                    wet: 0.1,
                    preDelay: 0.01
                }).connect(limiter);
                
                // Wait for reverb to generate IR
                await reverb.generate();
                
                // Show loading status
                loadingOverlay.querySelector('.loading-text').textContent = "Loading Piano Samples...";
                loadingOverlay.querySelector('.loading-subtext').textContent = "Please wait...";
                
                // Set a timeout for sample loading - 10 seconds max
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error("Timeout loading samples")), 10000);
                });
                
                try {
                    // Try to load the piano samples with a timeout
                    const samplerPromise = new Promise((resolve, reject) => {
                        // Use fewer samples for mobile
                        const sampler = new Tone.Sampler({
                            urls: {
                                "A1": "A1.mp3",
                                "A3": "A3.mp3", 
                                "A5": "A5.mp3",
                                "C2": "C2.mp3",
                                "C4": "C4.mp3",
                                "C6": "C6.mp3",
                                "D#3": "Ds3.mp3",
                                "D#5": "Ds5.mp3",
                                "F#2": "Fs2.mp3",
                                "F#4": "Fs4.mp3",
                                "F#6": "Fs6.mp3"
                            },
                            release: 1,
                            baseUrl: "https://tonejs.github.io/audio/salamander/",
                            onload: () => resolve(sampler),
                            onerror: (error) => reject(error)
                        }).connect(reverb);
                        
                        // Set initial volume
                        sampler.volume.value = -6; // -6dB to prevent clipping
                    });
                    
                    // Race between loading samples and timeout
                    pianoSampler = await Promise.race([samplerPromise, timeoutPromise]);
                    loadingOverlay.style.display = 'none';
                    
                    // Show status indicator
                    audioStatus.textContent = "Using Piano Samples";
                    audioStatus.classList.add("active");
                    audioStatus.classList.remove("fallback");
                    
                    // Hide status after 3 seconds
                    setTimeout(() => {
                        audioStatus.classList.remove("active");
                    }, 3000);
                    
                    usingFallbackSynth = false;
                    console.log("Piano samples loaded successfully");
                    return pianoSampler;
                    
                } catch (sampleError) {
                    console.warn("Failed to load piano samples:", sampleError);
                    loadingOverlay.querySelector('.loading-text').textContent = "Using Simple Synth";
                    loadingOverlay.querySelector('.loading-subtext').textContent = "Sample loading failed, using fallback";
                    
                    // Fallback to a simple synth that doesn't need samples
                    pianoSampler = new Tone.PolySynth(Tone.Synth, {
                        envelope: {
                            attack: 0.02,
                            decay: 0.1,
                            sustain: 0.3,
                            release: 1
                        },
                        oscillator: {
                            type: "triangle"
                        }
                    }).connect(reverb);
                    
                    // Set volume for the synth
                    pianoSampler.volume.value = -10;
                    
                    // Add a 'loaded' property to match the Sampler API
                    pianoSampler.loaded = true;
                    
                    // Show fallback status indicator
                    audioStatus.textContent = "Using Fallback Synth";
                    audioStatus.classList.add("active");
                    audioStatus.classList.add("fallback");
                    
                    // Keep fallback status visible for 5 seconds
                    setTimeout(() => {
                        audioStatus.classList.remove("active");
                    }, 5000);
                    
                    usingFallbackSynth = true;
                    
                    // Hide loading overlay after 1.5 seconds to show the user the fallback message
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 1500);
                    
                    return pianoSampler;
                }
            } catch (error) {
                showError("Error initializing audio: " + error.message);
                // Display loading overlay with an error message
                loadingOverlay.querySelector('.loading-text').textContent = "Audio Error";
                loadingOverlay.querySelector('.loading-subtext').textContent = "Please tap to retry";
                return null;
            }
        }
        
        // Initialize audio context on user interaction (required for mobile browsers)
        async function initAudio() {
            try {
                if (!isAudioInitialized) {
                    await Tone.start();
                    isAudioInitialized = true;
                    await initPiano();
                    generateKeyboard();
                    
                    // Fix Android display after initialization
                    fixAndroidDisplay();
                    
                    // Initialize displays
                    updateOctaveDisplay();
                    updateKeySizeDisplay();
                }
            } catch (error) {
                showError("Could not start audio context: " + error.message);
            }
        }
        
        // Start audio initialization on user gesture
        loadingOverlay.addEventListener('click', async () => {
            loadingOverlay.querySelector('.loading-text').textContent = "Starting audio...";
            await initAudio();
        });
        
        // Convert MIDI note number to note name
        function midiNoteToName(midiNote) {
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            return `${notes[noteIndex]}${octave}`;
        }
        
        // Format time as mm:ss
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Play a note with error handling
        function playNote(note, velocity = 0.7) {
            // Skip if piano sampler isn't loaded yet
            if (!pianoSampler || !pianoSampler.loaded) return;
            
            try {
                let noteName;
                
                if (typeof note === 'object' && note.target) {
                    // DOM event
                    const key = note.target.closest('.white-key, .black-key');
                    if (!key) return;
                    noteName = key.dataset.note;
                    key.classList.add('active');
                    
                    // Prevent default to avoid scrolling on mobile
                    if (note.preventDefault) note.preventDefault();
                } else if (typeof note === 'object' && note.midiNote !== undefined) {
                    // MIDI event object
                    noteName = midiNoteToName(note.midiNote);
                    velocity = note.velocity !== undefined ? note.velocity : 0.7;
                    
                    // Visual feedback
                    const keyElement = document.querySelector(`.white-key[data-note="${noteName}"], .black-key[data-note="${noteName}"]`);
                    if (keyElement) {
                        keyElement.classList.add('active');
                    }
                } else if (typeof note === 'string') {
                    // Direct note name
                    noteName = note;
                } else if (typeof note === 'number') {
                    // MIDI note number
                    noteName = midiNoteToName(note);
                }
                
                if (noteName) {
                    // Play the note with the sampler
                    pianoSampler.triggerAttack(noteName, Tone.now(), velocity);
                }
            } catch (error) {
                console.error("Error playing note:", error);
            }
        }
        
        // Stop a note with error handling
        function stopNote(note) {
            // Skip if piano sampler isn't loaded yet
            if (!pianoSampler || !pianoSampler.loaded) return;
            
            try {
                let noteName;
                
                if (typeof note === 'object' && note.target) {
                    // DOM event
                    const key = note.target.closest('.white-key, .black-key');
                    if (!key) return;
                    noteName = key.dataset.note;
                    key.classList.remove('active');
                    
                    // Prevent default to avoid scrolling on mobile
                    if (note.preventDefault) note.preventDefault();
                } else if (typeof note === 'object' && note.midiNote !== undefined) {
                    // MIDI event object
                    noteName = midiNoteToName(note.midiNote);
                    
                    // Visual feedback
                    const keyElement = document.querySelector(`.white-key[data-note="${noteName}"], .black-key[data-note="${noteName}"]`);
                    if (keyElement) {
                        keyElement.classList.remove('active');
                    }
                } else if (typeof note === 'string') {
                    // Direct note name
                    noteName = note;
                } else if (typeof note === 'number') {
                    // MIDI note number
                    noteName = midiNoteToName(note);
                }
                
                if (noteName) {
                    // Release the note with the sampler
                    pianoSampler.triggerRelease(noteName, Tone.now());
                }
            } catch (error) {
                console.error("Error stopping note:", error);
            }
        }
        
        // Determine if the device is mobile
        function isMobileDevice() {
            return (window.innerWidth <= 768) || 
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                   /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Specifically check if it's Android
        function isAndroidDevice() {
            return /Android/i.test(navigator.userAgent);
        }
        
        // Generate keyboard based on current range and size settings
        function generateKeyboard() {
            try {
                const container = document.getElementById('piano-keys');
                if (!container) return;
                
                container.innerHTML = ''; // Clear any existing content
                
                // Calculate black key width based on white key width
                const blackKeyWidth = Math.round(whiteKeyWidth * blackKeyWidthRatio);
                
                // Set the keyboard range based on start and end octaves
                const octaveStart = startOctave;
                const octaveEnd = endOctave;
                
                // Count white keys in the range
                let whiteKeyCount = 0;
                for (let currentOctave = octaveStart; currentOctave <= octaveEnd; currentOctave++) {
                    for (let i = 0; i < notes.length; i++) {
                        const noteName = notes[i];
                        // Skip if we've reached the end octave and gone past C
                        if (currentOctave === octaveEnd && i > notes.indexOf('C')) break;
                        
                        if (!isBlackKey[noteName]) {
                            whiteKeyCount++;
                        }
                    }
                }
                
                // Set container width based on white keys
                container.style.width = `${whiteKeyCount * whiteKeyWidth}px`;
                
                // Keep track of white key elements for black key positioning
                const whiteKeyElements = [];
                
                // First pass: create all white keys
                for (let currentOctave = octaveStart; currentOctave <= octaveEnd; currentOctave++) {
                    for (let i = 0; i < notes.length; i++) {
                        const noteName = notes[i];
                        // Skip if we've reached the end octave and gone past C
                        if (currentOctave === octaveEnd && i > notes.indexOf('C')) break;
                        
                        const noteWithOctave = `${noteName}${currentOctave}`;
                        
                        // Create white key if it's a natural note (no #)
                        if (!isBlackKey[noteName]) {
                            const whiteKey = document.createElement('div');
                            whiteKey.className = 'white-key';
                            whiteKey.dataset.note = noteWithOctave;
                            whiteKey.dataset.noteName = noteName;
                            whiteKey.style.width = `${whiteKeyWidth}px`;
                            
                            // Add label
                            const label = document.createElement('div');
                            label.className = 'key-label';
                            label.textContent = noteWithOctave;
                            whiteKey.appendChild(label);
                            
                            // Add event listeners
                            whiteKey.addEventListener('mousedown', playNote);
                            whiteKey.addEventListener('touchstart', playNote, { passive: false });
                            whiteKey.addEventListener('mouseup', stopNote);
                            whiteKey.addEventListener('mouseleave', stopNote);
                            whiteKey.addEventListener('touchend', stopNote);
                            
                            container.appendChild(whiteKey);
                            whiteKeyElements.push({
                                element: whiteKey,
                                note: noteName,
                                noteWithOctave: noteWithOctave,
                                octave: currentOctave
                            });
                        }
                    }
                }
                
                // Second pass: add black keys with correct positioning
                for (let currentOctave = octaveStart; currentOctave <= octaveEnd; currentOctave++) {
                    for (let i = 0; i < notes.length; i++) {
                        const noteName = notes[i];
                        // Skip if we've reached the end octave and gone past C
                        if (currentOctave === octaveEnd && i > notes.indexOf('C')) break;
                        
                        const noteWithOctave = `${noteName}${currentOctave}`;
                        
                        // Create black key if it's a sharp note
                        if (isBlackKey[noteName]) {
                            // Find the white key that corresponds to this black key
                            const prevNoteIndex = (i - 1 + 12) % 12;
                            const prevNoteName = notes[prevNoteIndex];
                            
                            // Find the white key element for positioning
                            let prevWhiteKey = null;
                            
                            for (let j = 0; j < whiteKeyElements.length; j++) {
                                const keyInfo = whiteKeyElements[j];
                                
                                if (keyInfo.note === prevNoteName && keyInfo.octave === currentOctave) {
                                    prevWhiteKey = keyInfo.element;
                                    break;
                                }
                            }
                            
                            if (prevWhiteKey) {
                                const blackKey = document.createElement('div');
                                blackKey.className = 'black-key';
                                blackKey.dataset.note = noteWithOctave;
                                
                                // Position the black key relative to the white key
                                const whiteKeyLeft = prevWhiteKey.offsetLeft;
                                const offset = whiteKeyWidth * blackKeyPositions[noteName];
                                blackKey.style.left = `${whiteKeyLeft + offset}px`;
                                blackKey.style.width = `${blackKeyWidth}px`;
                                
                                // Add event listeners
                                blackKey.addEventListener('mousedown', playNote);
                                blackKey.addEventListener('touchstart', playNote, { passive: false });
                                blackKey.addEventListener('mouseup', stopNote);
                                blackKey.addEventListener('mouseleave', stopNote);
                                blackKey.addEventListener('touchend', stopNote);
                                
                                container.appendChild(blackKey);
                            }
                        }
                    }
                }
                
                // Scroll to middle C (C4) initially if it's in our range
                setTimeout(() => {
                    if (startOctave <= 4 && endOctave >= 4) {
                        const middleC = document.querySelector('.white-key[data-note="C4"]');
                        if (middleC) {
                            const containerWidth = pianoContainer.clientWidth;
                            const scrollPosition = middleC.offsetLeft - (containerWidth / 2) + (whiteKeyWidth/2);
                            pianoContainer.scrollLeft = scrollPosition;
                        }
                    } else {
                        // If middle C is not in range, scroll to the center of the keyboard
                        pianoContainer.scrollLeft = (whiteKeyCount * whiteKeyWidth - pianoContainer.clientWidth) / 2;
                    }
                }, 100);
            } catch (error) {
                showError("Error generating keyboard: " + error.message);
            }
        }
        
        // Update playhead position based on current time - simplified for Android
        function updatePlayhead() {
            if (!midiData) return;
            
            try {
                // Update timeline scrubber
                timelineScrubber.value = (currentTime / midiDuration) * 100;
                
                // Update time display
                currentTimeDisplay.textContent = formatTime(currentTime);
                
                // Update playhead in score view if active
                if (scoreContainer.classList.contains('active') && playhead) {
                    // Calculate position based on piano roll dimensions
                    if (pianoRollContainer && pianoRollWidth > 0) {
                        const TIME_SCALE = 100; // Must match createPianoRoll
                        const position = currentTime * TIME_SCALE;
                        
                        // Make playhead visible
                        playhead.style.display = 'block';
                        
                        // Position the playhead
                        playhead.style.left = `${position + 60}px`; // Add sidebar width
                    }
                }
            } catch (error) {
                console.error("Error updating playhead:", error);
            }
        }
        
        // Create simplified piano roll visualization for Android
        function createPianoRoll() {
            if (!midiData) return;
            
            try {
                // Clear previous content
                const sheetContainer = document.getElementById('sheet-container');
                sheetContainer.innerHTML = '<div class="sheet-title" id="sheet-title">Music Sheet</div>';
                
                // Update title with filename if available
                if (midiFile) {
                    document.getElementById('sheet-title').textContent = midiFile.name.replace(/\.[^/.]+$/, "");
                }
                
                // Create piano roll container
                pianoRollContainer = document.createElement('div');
                pianoRollContainer.className = 'piano-roll-container';
                pianoRollContainer.style.height = '300px'; // Reduced height for mobile
                sheetContainer.appendChild(pianoRollContainer);
                
                // Create piano roll
                const pianoRoll = document.createElement('div');
                pianoRoll.className = 'piano-roll';
                pianoRollContainer.appendChild(pianoRoll);
                
                // Create sidebar for note names
                const sidebar = document.createElement('div');
                sidebar.className = 'piano-roll-sidebar';
                pianoRoll.appendChild(sidebar);
                
                // Create main area for notes
                const main = document.createElement('div');
                main.className = 'piano-roll-main';
                pianoRoll.appendChild(main);
                
                // Get all unique notes
                const allNotes = [];
                midiData.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        if (!allNotes.includes(note.midi)) {
                            allNotes.push(note.midi);
                        }
                    });
                });
                
                // Limit the range of displayed notes to improve performance
                allNotes.sort((a, b) => b - a);
                const NOTE_HEIGHT = 20;
                const TIME_SCALE = 100; // pixels per second
                
                // Limit the height for performance
                const maxNotes = 30; // Display maximum 30 notes vertically
                const displayedNotes = allNotes.slice(0, maxNotes);
                
                const totalHeight = displayedNotes.length * NOTE_HEIGHT;
                const totalWidth = Math.min(midiDuration * TIME_SCALE, 5000); // Limit width for performance
                
                // Store piano roll width for playhead positioning
                pianoRollWidth = totalWidth;
                
                // Set dimensions
                pianoRoll.style.height = `${totalHeight}px`;
                main.style.width = `${totalWidth}px`;
                
                // Create labels for notes in sidebar (only for displayed notes)
                displayedNotes.forEach((midiNote, index) => {
                    const noteName = midiNoteToName(midiNote);
                    const noteLabel = document.createElement('div');
                    noteLabel.style.position = 'absolute';
                    noteLabel.style.top = `${index * NOTE_HEIGHT}px`;
                    noteLabel.style.height = `${NOTE_HEIGHT}px`;
                    noteLabel.style.width = '100%';
                    noteLabel.style.borderBottom = '1px solid #ccc';
                    noteLabel.style.display = 'flex';
                    noteLabel.style.alignItems = 'center';
                    noteLabel.style.justifyContent = 'center';
                    noteLabel.style.fontSize = '10px';
                    noteLabel.style.color = '#333';
                    noteLabel.textContent = noteName;
                    
                    // Style differently for black keys
                    if (noteName.includes('#')) {
                        noteLabel.style.backgroundColor = '#ddd';
                    }
                    
                    sidebar.appendChild(noteLabel);
                });
                
                // Only show vertical grid lines every 4 seconds to reduce elements
                for (let i = 0; i <= midiDuration; i += 4) {
                    const gridLine = document.createElement('div');
                    gridLine.style.position = 'absolute';
                    gridLine.style.top = '0';
                    gridLine.style.bottom = '0';
                    gridLine.style.left = `${i * TIME_SCALE}px`;
                    gridLine.style.width = '1px';
                    gridLine.style.backgroundColor = '#aaa';
                    main.appendChild(gridLine);
                    
                    // Add time marker
                    const timeMarker = document.createElement('div');
                    timeMarker.style.position = 'absolute';
                    timeMarker.style.top = '-15px';
                    timeMarker.style.left = `${i * TIME_SCALE}px`;
                    timeMarker.style.fontSize = '10px';
                    timeMarker.style.color = '#666';
                    timeMarker.textContent = formatTime(i);
                    main.appendChild(timeMarker);
                }
                
                // Render notes for each track (with limit for performance)
                let noteCount = 0;
                const MAX_NOTES = 1000; // Limit total number of note elements
                
                midiData.tracks.forEach((track, trackIndex) => {
                    // Assign a color to each track
                    const hue = (trackIndex * 40) % 360;
                    const noteColor = `hsl(${hue}, 70%, 60%)`;
                    
                    // Get notes with duration > 0.1s to reduce tiny notes
                    const significantNotes = track.notes.filter(note => note.duration > 0.1);
                    
                    for (let note of significantNotes) {
                        if (noteCount >= MAX_NOTES) break; // Stop if too many notes
                        
                        // Find the note's vertical position
                        const noteIndex = displayedNotes.indexOf(note.midi);
                        if (noteIndex === -1) continue; // Skip notes not in our display range
                        
                        // Create note element
                        const noteElement = document.createElement('div');
                        noteElement.className = 'piano-roll-note';
                        noteElement.style.top = `${noteIndex * NOTE_HEIGHT + 2}px`; // +2 for spacing
                        noteElement.style.left = `${note.time * TIME_SCALE}px`;
                        noteElement.style.width = `${note.duration * TIME_SCALE}px`;
                        noteElement.style.height = `${NOTE_HEIGHT - 4}px`; // -4 for spacing
                        noteElement.style.backgroundColor = noteColor;
                        
                        main.appendChild(noteElement);
                        noteCount++;
                    }
                });
                
                // Add playhead
                const playheadElement = document.createElement('div');
                playheadElement.id = 'playhead';
                playheadElement.className = 'playhead';
                playheadElement.style.height = `${totalHeight}px`;
                playheadElement.style.top = '0';
                
                // Position the playhead initially
                const initialPosition = (currentTime / midiDuration) * totalWidth;
                playheadElement.style.left = `${initialPosition + 60}px`; // Add sidebar width
                
                pianoRoll.appendChild(playheadElement);
                
                // Update global reference to playhead
                playhead = playheadElement;
                
                // Update playhead position initially
                updatePlayhead();
                
                // Add bottom spacer to ensure visibility
                const bottomSpacer = document.createElement('div');
                bottomSpacer.className = 'bottom-spacer';
                sheetContainer.appendChild(bottomSpacer);
            } catch (error) {
                showError("Error creating piano roll: " + error.message);
            }
        }
        
        // Parse and prepare MIDI file for playback (simplified for Android)
        async function parseMIDIFile(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                
                // Check file size for Android performance
                if (arrayBuffer.byteLength > 5 * 1024 * 1024) {
                    showError("File is too large. Please use a smaller MIDI file.");
                    return false;
                }
                
                // Parse MIDI file using Tone.js Midi
                midiData = new Midi(arrayBuffer);
                
                if (!midiData || !midiData.tracks || midiData.tracks.length === 0) {
                    showError("Invalid MIDI file or no tracks found");
                    return false;
                }
                
                // Store the duration
                midiDuration = midiData.duration;
                
                // On mobile, limit duration for performance
                if (isMobileDevice() && midiDuration > 300) {
                    showError("This MIDI file is too long. Please use a shorter file on mobile devices.");
                    return false;
                }
                
                // Set up timeline
                timelineScrubber.value = 0;
                totalTimeDisplay.textContent = formatTime(midiDuration);
                
                // Create piano roll if in score view
                if (scoreContainer.classList.contains('active')) {
                    createPianoRoll();
                }
                
                // Success
                return true;
            } catch (error) {
                showError("Error parsing MIDI file: " + error.message);
                return false;
            }
        }
        
        // Start MIDI playback with optimizations for Android
        async function startMIDIPlayback() {
            if (!midiData || !pianoSampler || !pianoSampler.loaded) {
                showError("Piano samples not loaded. Please wait or refresh the page.");
                return;
            }
            
            try {
                // Clear any previous playback
                stopMIDIPlayback(false);
                
                // Check if Tone.js is started
                if (Tone.context.state !== 'running') {
                    try {
                        await Tone.start();
                        isAudioInitialized = true;
                    } catch (err) {
                        showError("Could not start audio: " + err.message + " - Please tap the screen.");
                        return;
                    }
                }
                
                const fileInfo = document.getElementById('file-info');
                fileInfo.textContent = 'Playing...';
                
                isPlaying = true;
                isPaused = false;
                
                // Update UI
                document.getElementById('play-btn').disabled = true;
                document.getElementById('pause-btn').disabled = false;
                document.getElementById('stop-btn').disabled = false;
                
                // Set the tempo from the MIDI file
                if (midiData.header.tempos.length > 0) {
                    Tone.Transport.bpm.value = midiData.header.tempos[0].bpm;
                }
                
                // For Android performance, simplify event handling
                // Prepare all note events across all tracks with filtering for performance
                const allEvents = [];
                
                // Track events with consolidation for better performance
                midiData.tracks.forEach((track) => {
                    // Filter out tracks with too many notes for mobile
                    if (isMobileDevice() && track.notes.length > 1000) {
                        return; // Skip tracks with too many notes on mobile
                    }
                    
                    // Filter short notes that may cause performance issues
                    const significantNotes = track.notes.filter(note => note.duration >= 0.1);
                    
                    significantNotes.forEach((note) => {
                        // Note on event
                        allEvents.push({
                            time: note.time,
                            note: note.name,
                            midi: note.midi,
                            velocity: note.velocity,
                            duration: note.duration,
                            type: 'noteon'
                        });
                        
                        // Note off event
                        allEvents.push({
                            time: note.time + note.duration,
                            note: note.name,
                            midi: note.midi,
                            type: 'noteoff'
                        });
                    });
                });
                
                // Sort events by time
                allEvents.sort((a, b) => a.time - b.time);
                
                // Limit events for performance on mobile
                const limitedEvents = isMobileDevice() ? 
                    allEvents.slice(0, Math.min(10000, allEvents.length)) : 
                    allEvents;
                
                // Create a Part to schedule all the events
                midiPart = new Tone.Part((time, event) => {
                    // Skip out-of-range events
                    if (event.time > midiDuration) return;
                    
                    if (event.type === 'noteon') {
                        // Play note and show visual feedback
                        pianoSampler.triggerAttack(event.note, time, event.velocity);
                        
                        // Visual feedback (only if the key exists in our limited keyboard)
                        const keyElement = document.querySelector(`.white-key[data-note="${event.note}"], .black-key[data-note="${event.note}"]`);
                        if (keyElement) {
                            Tone.Draw.schedule(() => {
                                keyElement.classList.add('active');
                                
                                // Auto-scroll to keep the active key visible
                                const keyRect = keyElement.getBoundingClientRect();
                                const containerRect = pianoContainer.getBoundingClientRect();
                                
                                if (keyRect.left < containerRect.left || keyRect.right > containerRect.right) {
                                    const scrollOffset = keyElement.offsetLeft - (pianoContainer.clientWidth / 2) + (keyElement.offsetWidth / 2);
                                    pianoContainer.scrollLeft = scrollOffset;
                                }
                            }, time);
                        }
                    } else if (event.type === 'noteoff') {
                        // Release note and remove visual feedback
                        pianoSampler.triggerRelease(event.note, time);
                        
                        // Remove visual feedback
                        const keyElement = document.querySelector(`.white-key[data-note="${event.note}"], .black-key[data-note="${event.note}"]`);
                        if (keyElement) {
                            Tone.Draw.schedule(() => {
                                keyElement.classList.remove('active');
                            }, time);
                        }
                    }
                }, limitedEvents).start(0);
                
                // Use a less frequent update for the playhead on Android
                const updateInterval = isMobileDevice() ? 0.1 : 0.03; // 10fps on mobile
                
                // Setup playhead movement
                Tone.Transport.scheduleRepeat((time) => {
                    Tone.Draw.schedule(() => {
                        currentTime = Tone.Transport.seconds;
                        updatePlayhead();
                    }, time);
                }, updateInterval);
                
                // Set end callback
                Tone.Transport.schedule((time) => {
                    stopMIDIPlayback();
                }, midiDuration + 1); // Add 1 second buffer
                
                // Start the Transport from the current position
                Tone.Transport.start("+0.1", currentTime);
            } catch (error) {
                showError("Error starting playback: " + error.message);
                stopMIDIPlayback(true);
            }
        }
        
        // Pause MIDI playback
        function pauseMIDIPlayback() {
            if (!isPlaying) return;
            
            try {
                isPaused = true;
                isPlaying = false;
                
                // Store current time
                currentTime = Tone.Transport.seconds;
                
                // Pause the Transport (stops all scheduled events)
                Tone.Transport.pause();
                
                // Reset all active key visuals
                document.querySelectorAll('.white-key.active, .black-key.active').forEach(key => {
                    key.classList.remove('active');
                });
                
                const fileInfo = document.getElementById('file-info');
                fileInfo.textContent = 'Paused';
                
                // Enable play button, disable pause button
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
                document.getElementById('stop-btn').disabled = false;
            } catch (error) {
                showError("Error pausing playback: " + error.message);
            }
        }
        
        // Stop MIDI playback
        function stopMIDIPlayback(updateUI = true) {
            try {
                isPaused = false;
                isPlaying = false;
                currentTime = 0;
                
                // Stop the Transport
                Tone.Transport.stop();
                
                // Dispose of the Part to free up resources
                if (midiPart) {
                    midiPart.dispose();
                    midiPart = null;
                }
                
                // Reset all active key visuals
                document.querySelectorAll('.white-key.active, .black-key.active').forEach(key => {
                    key.classList.remove('active');
                });
                
                // Release all notes
                if (pianoSampler && pianoSampler.loaded) {
                    pianoSampler.releaseAll();
                }
                
                // Update playhead
                updatePlayhead();
                
                if (updateUI) {
                    const fileInfo = document.getElementById('file-info');
                    fileInfo.textContent = midiFile ? `Ready to play: ${midiFile.name}` : 'No file loaded';
                    
                    // Update button states
                    document.getElementById('play-btn').disabled = !midiFile;
                    document.getElementById('pause-btn').disabled = true;
                    document.getElementById('stop-btn').disabled = true;
                }
            } catch (error) {
                console.error("Error stopping playback:", error);
            }
        }
        
        // Event Listeners - Simplified for Android
        
        // Toggle between keyboard and score view
        viewToggle.addEventListener('click', () => {
            try {
                viewToggle.classList.toggle('active');
                pianoContainer.classList.toggle('with-score');
                scoreContainer.classList.toggle('active');
                
                // If switching to score view, create the piano roll
                if (scoreContainer.classList.contains('active') && midiData) {
                    createPianoRoll();
                } else {
                    // If switching away from score view, hide the playhead
                    if (playhead) {
                        playhead.style.display = 'none';
                    }
                }
                
                // Fix Android display after toggling
                fixAndroidDisplay();
            } catch (error) {
                showError("Error toggling view: " + error.message);
            }
        });
        
        // Handle timeline scrubber input
        timelineScrubber.addEventListener('input', () => {
            if (!midiData) return;
            
            try {
                // Calculate time based on percentage
                const percent = timelineScrubber.value / 100;
                currentTime = percent * midiDuration;
                
                // Update current time display
                currentTimeDisplay.textContent = formatTime(currentTime);
                
                // Update playhead if in score view
                if (scoreContainer.classList.contains('active')) {
                    updatePlayhead();
                }
            } catch (error) {
                console.error("Error with timeline input:", error);
            }
        });
        
        // Handle timeline scrubber change (when user releases)
        timelineScrubber.addEventListener('change', () => {
            if (!midiData) return;
            
            try {
                // Calculate time based on percentage
                const percent = timelineScrubber.value / 100;
                currentTime = percent * midiDuration;
                
                // If playing, update transport position
                if (isPlaying) {
                    Tone.Transport.seconds = currentTime;
                }
            } catch (error) {
                console.error("Error with timeline change:", error);
            }
        });
        
        // Handle MIDI file upload
        document.getElementById('midi-upload').addEventListener('change', async (e) => {
            try {
                const file = e.target.files[0];
                if (!file) return;
                
                if (!file.name.toLowerCase().endsWith('.mid') && !file.name.toLowerCase().endsWith('.midi')) {
                    showError('Please select a valid MIDI file (.mid or .midi)');
                    return;
                }
                
                // Ensure audio is initialized
                if (!isAudioInitialized) {
                    try {
                        await Tone.start();
                        isAudioInitialized = true;
                    } catch (err) {
                        showError("Please tap the screen to enable audio");
                        return;
                    }
                }
                
                // Check size for mobile
                if (isMobileDevice() && file.size > 2 * 1024 * 1024) {
                    showError("File is too large for mobile. Please use a smaller MIDI file.");
                    return;
                }
                
                // Update UI to show loading state
                const fileInfo = document.getElementById('file-info');
                fileInfo.textContent = 'Loading MIDI file...';
                
                // Stop any current playback
                stopMIDIPlayback(false);
                
                try {
                    const success = await parseMIDIFile(file);
                    
                    if (success) {
                        midiFile = file;
                        fileInfo.textContent = `Ready to play: ${file.name.substring(0, 30)}${file.name.length > 30 ? '...' : ''}`;
                        document.getElementById('play-btn').disabled = false;
                        document.getElementById('pause-btn').disabled = true;
                        document.getElementById('stop-btn').disabled = true;
                        
                        // If score view is active, create the piano roll
                        if (scoreContainer.classList.contains('active')) {
                            createPianoRoll();
                        }
                    } else {
                        fileInfo.textContent = 'Error: Invalid MIDI file';
                        document.getElementById('play-btn').disabled = true;
                        document.getElementById('pause-btn').disabled = true;
                        document.getElementById('stop-btn').disabled = true;
                    }
                } catch (error) {
                    showError("Error processing MIDI file: " + error.message);
                    fileInfo.textContent = 'Error processing file';
                    document.getElementById('play-btn').disabled = true;
                    document.getElementById('pause-btn').disabled = true;
                    document.getElementById('stop-btn').disabled = true;
                }
            } catch (error) {
                showError("File upload error: " + error.message);
            }
        });
        
        // Playback control button events
        document.getElementById('play-btn').addEventListener('click', startMIDIPlayback);
        document.getElementById('pause-btn').addEventListener('click', pauseMIDIPlayback);
        document.getElementById('stop-btn').addEventListener('click', () => stopMIDIPlayback(true));
        
        // Hide controls overlay when interacting with piano on mobile
        pianoContainer.addEventListener('touchstart', () => {
            try {
                // Ensure audio is initialized on first touch
                if (!isAudioInitialized) {
                    Tone.start()
                        .then(() => {
                            isAudioInitialized = true;
                            if (!pianoSampler) {
                                initPiano().then(() => generateKeyboard());
                            }
                        })
                        .catch(err => {
                            showError("Could not start audio: " + err.message);
                        });
                }
            } catch (error) {
                console.error("Error on touch start:", error);
            }
        });
        
        // Handle touch events for multi-touch - simplified for Android
        let touchedKeys = new Set();
        let isTouchActive = false;
        
        // Process current touches and update active keys
        function processCurrentTouches(touches) {
            if (!pianoSampler || !pianoSampler.loaded) return;
            
            try {
                const currentTouches = new Set();
                
                // Limit to 5 touches for Android performance
                const touchLimit = Math.min(touches.length, 5);
                
                for (let i = 0; i < touchLimit; i++) {
                    const touch = touches[i];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    const key = element?.closest('.white-key, .black-key');
                    
                    if (key) {
                        const note = key.dataset.note;
                        currentTouches.add(note);
                        
                        // If not already playing this note, start it
                        if (!touchedKeys.has(note)) {
                            playNote(note);
                            key.classList.add('active');
                            touchedKeys.add(note);
                        }
                    }
                }
                
                // Stop notes that are no longer being touched
                for (const note of touchedKeys) {
                    if (!currentTouches.has(note)) {
                        stopNote(note);
                        const key = document.querySelector(`.white-key[data-note="${note}"], .black-key[data-note="${note}"]`);
                        if (key) {
                            key.classList.remove('active');
                        }
                        touchedKeys.delete(note);
                    }
                }
            } catch (error) {
                console.error("Error processing touches:", error);
            }
        }
        
        // Touch start
        document.addEventListener('touchstart', (e) => {
            try {
                if (isPlaying) return; // Don't allow manual playing during MIDI playback
                
                isTouchActive = true;
                
                // Ensure audio is initialized
                if (!isAudioInitialized) {
                    Tone.start()
                        .then(() => {
                            isAudioInitialized = true;
                            if (!pianoSampler) {
                                initPiano().then(() => generateKeyboard());
                            }
                        })
                        .catch(err => {
                            showError("Could not start audio: " + err.message);
                        });
                }
                
                // Process touches
                processCurrentTouches(e.touches);
                
            } catch (error) {
                console.error("Error on touch start:", error);
            }
        }, { passive: false });
        
        // Touch move
        document.addEventListener('touchmove', (e) => {
            try {
                if (isPlaying || !isTouchActive) return;
                
                // Prevent scrolling while playing piano
                if (e.target.closest('.piano-container')) {
                    e.preventDefault();
                }
                
                // Process touches
                processCurrentTouches(e.touches);
                
            } catch (error) {
                console.error("Error on touch move:", error);
            }
        }, { passive: false });
        
        // Touch end
        document.addEventListener('touchend', (e) => {
            try {
                if (isPlaying) return;
                
                // If no more touches, clear all touched keys
                if (e.touches.length === 0) {
                    isTouchActive = false;
                    
                    // Release all touched keys
                    for (const note of touchedKeys) {
                        stopNote(note);
                        const key = document.querySelector(`.white-key[data-note="${note}"], .black-key[data-note="${note}"]`);
                        if (key) {
                            key.classList.remove('active');
                        }
                    }
                    touchedKeys.clear();
                } else {
                    // Some touches remain, update active keys
                    processCurrentTouches(e.touches);
                }
            } catch (error) {
                console.error("Error on touch end:", error);
            }
        });
        
        // Adjust keyboard on window resize - simplified for Android
        window.addEventListener('resize', () => {
            try {
                // Fix Android display on resize
                fixAndroidDisplay();
                
                // Regenerate the keyboard for new screen size
                if (pianoSampler && pianoSampler.loaded) {
                    generateKeyboard();
                }
                
                // Recreate piano roll if it's active
                if (scoreContainer.classList.contains('active') && midiData) {
                    createPianoRoll();
                }
            } catch (error) {
                console.error("Error on resize:", error);
            }
        });
        
        // Global error handling
        window.addEventListener('error', function(event) {
            showError("Error: " + event.message);
            console.error("Global error:", event.error);
        });
        
        // Initialize with a more passive approach for Android
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Fix Android display issues first
                fixAndroidDisplay();
                
                // Set controls to be visible by default
                controlsOverlay.style.display = 'flex';
                
                // Set initial slider values
                octaveSlider.value = startOctave;
                keySizeSlider.value = whiteKeyWidth;
                
                // Update displays
                updateOctaveDisplay();
                updateKeySizeDisplay();
                
                // Show the loading overlay with instructions
                loadingOverlay.style.display = 'flex';
                loadingOverlay.querySelector('.loading-text').textContent = 'Tap to Start Piano';
                loadingOverlay.querySelector('.loading-subtext').textContent = 'Audio requires user interaction';
                
                // Detect Android platform and show specific message
                if (isAndroidDevice()) {
                    console.log("Android device detected, optimizing performance");
                    // Display a friendly message specific to Android users
                    loadingOverlay.querySelector('.loading-subtext').textContent = 'Tap to start (Android optimized)';
                }
            } catch (error) {
                console.error("Error during initialization:", error);
            }
        });
        
        // Run Android display fixes immediately
        fixAndroidDisplay();
    </script>



</body></html>
