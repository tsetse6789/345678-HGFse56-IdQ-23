<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Blast</title>
    <script src="../Hidden/Script/cdn.tailwindcss.com.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            touch-action: manipulation;
            overscroll-behavior: none;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(var(--columns), 1fr);
            grid-template-rows: repeat(var(--rows), 1fr);
            gap: 2px;
            background-color: rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .dark .game-board {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .cell {
            aspect-ratio: 1/1;
            border-radius: 2px;
            transition: background-color 0.1s ease;
            position: relative;
        }
        
        .block-piece {
            display: grid;
            grid-template-columns: repeat(var(--columns), 1fr);
            grid-template-rows: repeat(var(--rows), 1fr);
            gap: 2px;
            cursor: grab;
        }
        
        .block-piece:active {
            cursor: grabbing;
        }
        
        .piece-cell {
            aspect-ratio: 1/1;
            border-radius: 2px;
        }
        
        /* Clear effect animations */
        @keyframes sparkleFade {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1) rotate(180deg); opacity: 1; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }
        
        @keyframes lineGlow {
            0% { 
                box-shadow: 0 0 5px 2px rgba(255, 255, 255, 0.5);
                background-color: rgba(255, 255, 255, 0.9);
            }
            50% { 
                box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8);
                background-color: rgba(255, 255, 255, 1);
            }
            100% { 
                box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0);
                background-color: rgba(255, 255, 255, 0);
            }
        }
        
        @keyframes blockBreak {
            0% { 
                transform: scale(1); 
                opacity: 1; 
                clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            }
            15% { 
                transform: scale(1.05); 
                opacity: 1;
                clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            }
            20% { 
                transform: scale(1.05); 
                opacity: 0.95;
                clip-path: polygon(0% 0%, 45% 15%, 100% 0%, 100% 100%, 55% 85%, 0% 100%);
            }
            50% { 
                transform: scale(0.9) rotate(3deg); 
                opacity: 0.7;
                clip-path: polygon(15% 0%, 45% 15%, 85% 0%, 100% 45%, 85% 100%, 55% 85%, 15% 100%, 0% 45%);
            }
            100% { 
                transform: scale(0) rotate(-5deg); 
                opacity: 0;
                clip-path: polygon(25% 0%, 45% 25%, 75% 0%, 100% 35%, 75% 100%, 45% 75%, 25% 100%, 0% 35%);
            }
        }
        
        @keyframes fragmentFly {
            0% { 
                transform: translate(0, 0) rotate(0deg) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translate(var(--tx), var(--ty)) rotate(var(--rotate)) scale(0); 
                opacity: 0; 
            }
        }
        
        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: white;
            pointer-events: none;
            z-index: 10;
            animation: sparkleFade 0.7s ease-out forwards;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
        }
        
        .line-glow {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5;
            animation: lineGlow 0.8s ease-in-out forwards;
        }
        
        .cell.clearing {
            animation: blockBreak 0.7s ease-out forwards;
            z-index: 2;
        }
        
        .fragment {
            position: absolute;
            background-color: inherit;
            pointer-events: none;
            z-index: 15;
            border-radius: 2px;
            animation: fragmentFly 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }
        
        @keyframes flash {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.5; }
        }
        
        .flash-animation {
            animation: flash 0.5s ease-in-out;
        }
        
        @keyframes drop {
            0% { transform: translateY(-20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        
        .drop-animation {
            animation: drop 0.3s ease-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .shake-animation {
            animation: shake 0.3s ease-in-out;
        }
        
        .next-piece-container {
            display: grid;
            grid-template-columns: repeat(var(--columns), 1fr);
            grid-template-rows: repeat(var(--rows), 1fr);
            gap: 2px;
        }
        
        .dragging {
            opacity: 0.8;
            z-index: 100;
        }
        
        /* Drag clone styling */
        #dragClone {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.8;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            transition: none;
        }
        
        /* Highlight possible placement area */
        .cell.possible-placement {
            background-color: rgba(93, 92, 222, 0.2) !important;
        }
        
        /* Custom scrollbar for the instructions */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(93, 92, 222, 0.4);
            border-radius: 4px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(93, 92, 222, 0.6);
        }
        
        .dark .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 min-h-screen antialiased">
    <div class="container mx-auto px-4 py-6 max-w-4xl">
        <!-- Game title -->
        <h1 class="text-3xl md:text-4xl font-bold text-center text-primary mb-6">Block Blast</h1>
        
        <!-- Game container -->
        <div class="flex flex-col md:flex-row gap-6 items-start">
            <!-- Left column - Game board -->
            <div class="w-full md:w-2/3 bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
                <div id="gameBoard" class="game-board border-2 border-gray-200 dark:border-gray-700 w-full aspect-square"></div>
                
                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center">
                    <div>
                        <button id="rotateButton" class="px-4 py-2 bg-primary text-white rounded-lg mr-2 hover:bg-opacity-90 transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path>
                            </svg>
                            Rotate
                        </button>
                        <button id="resetButton" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-opacity-90 transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path>
                            </svg>
                            Reset
                        </button>
                    </div>
                    <div id="mobileDragInfo" class="text-sm text-gray-500 dark:text-gray-400 mt-2 sm:mt-0">
                        Drag blocks to place them
                    </div>
                </div>
            </div>
            
            <!-- Right column - Game info and next pieces -->
            <div class="w-full md:w-1/3 flex flex-col gap-4">
                <!-- Score and level display -->
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
                    <div class="flex justify-between items-center mb-3">
                        <div>
                            <h2 class="text-xl font-bold text-gray-800 dark:text-white">Score</h2>
                            <p id="scoreDisplay" class="text-3xl font-bold text-primary">0</p>
                        </div>
                        <div>
                            <h2 class="text-xl font-bold text-gray-800 dark:text-white">Level</h2>
                            <p id="levelDisplay" class="text-3xl font-bold text-primary">1</p>
                        </div>
                    </div>
                    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                        <div id="progressBar" class="bg-primary h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
                
                <!-- Current piece container (for mobile) - shown first on mobile with adaptive sizing -->
                <div id="currentPieceContainer" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4 sm:hidden">
                    <h2 class="text-xl font-bold text-gray-800 dark:text-white mb-2">Current Block</h2>
                    <div id="currentPiece" class="block-piece mx-auto" style="max-width: 80px; max-height: 80px;"></div>
                </div>
                
                <!-- Next piece preview - smaller on all screens -->
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
                    <h2 class="text-xl font-bold text-gray-800 dark:text-white mb-2">Next Block</h2>
                    <div id="nextPiece" class="next-piece-container mx-auto" style="max-width: 70px; max-height: 70px;"></div>
                </div>
                
                <!-- Instructions -->
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
                    <h2 class="text-xl font-bold text-gray-800 dark:text-white mb-2">How to Play</h2>
                    <div class="custom-scrollbar max-h-48 overflow-y-auto pr-2">
                        <ul class="text-sm text-gray-600 dark:text-gray-300 space-y-2">
                            <li>• Drag blocks to the board</li>
                            <li>• Tap or click "Rotate" to rotate blocks</li>
                            <li>• Fill complete rows or columns to clear them</li>
                            <li>• Clear multiple lines at once for bonus points</li>
                            <li>• Game ends when no more blocks can be placed</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- For desktop, we'll also have a draggable current piece floating with the cursor -->
        <div id="floatingCurrentPiece" class="block-piece absolute hidden sm:grid" style="width: 100px; height: 100px; pointer-events: none;"></div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="gameOverModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 mx-4 max-w-md w-full transform transition-all">
            <h2 class="text-2xl font-bold text-center text-red-500 mb-4">Game Over!</h2>
            <p class="text-gray-700 dark:text-gray-300 text-center mb-2">No more moves available.</p>
            <p class="text-xl font-bold text-center text-primary mb-6">Final Score: <span id="finalScore">0</span></p>
            
            <div class="flex flex-col sm:flex-row gap-3 justify-center">
                <button id="newGameButton" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-opacity-90 transition">
                    New Game
                </button>
                <button id="shareScoreButton" class="px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-opacity-90 transition">
                    Share Score
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // Check dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.add('light');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
                document.documentElement.classList.add('light');
            }
        });

        // Game Configuration
        const config = {
            boardSize: 8, // 8x8 grid
            initialBlocks: 3, // Show 3 blocks at start
            clearScoreBase: 100, // Base score for clearing a single line
            multiplierBonus: 2, // Multiply score for each additional line cleared simultaneously
            levelUpThreshold: 1000, // Score needed to level up
            maxLevel: 10
        };

        // Block colors - different for light/dark mode
        const blockColors = [
            { light: '#FF5252', dark: '#FF5252' }, // Red
            { light: '#FF9800', dark: '#FF9800' }, // Orange
            { light: '#FFEB3B', dark: '#FFEB3B' }, // Yellow
            { light: '#4CAF50', dark: '#4CAF50' }, // Green
            { light: '#2196F3', dark: '#2196F3' }, // Blue
            { light: '#9C27B0', dark: '#9C27B0' }, // Purple
            { light: '#E91E63', dark: '#E91E63' }  // Pink
        ];

        // Block shapes (similar to Tetris pieces but simplified for an 8x8 grid)
        const blockShapes = [
            // Single square
            [[1]],
            
            // 2x1 line
            [[1, 1]],
            
            // 1x2 line
            [[1], [1]],
            
            // 2x2 square
            [[1, 1], 
             [1, 1]],
             
            // L shape
            [[1, 0],
             [1, 1]],
             
            // Reverse L shape
            [[0, 1],
             [1, 1]],
             
            // T shape
            [[1, 1, 1],
             [0, 1, 0]],
             
            // Z shape
            [[1, 1, 0],
             [0, 1, 1]],
             
            // S shape
            [[0, 1, 1],
             [1, 1, 0]],
             
            // 3x1 line
            [[1, 1, 1]],
             
            // 1x3 line
            [[1], 
             [1], 
             [1]],
             
            // Plus shape (level 2+)
            [[0, 1, 0],
             [1, 1, 1],
             [0, 1, 0]],
             
            // U shape (level 3+)
            [[1, 0, 1],
             [1, 1, 1]],
             
            // 3x3 square (level 5+)
            [[1, 1, 1],
             [1, 1, 1],
             [1, 1, 1]]
        ];

        // Game State
        let gameState = {
            board: [],
            score: 0,
            level: 1,
            nextPieces: [],
            currentPiece: null,
            isGameOver: false,
            isDragging: false
        };

        // DOM Elements
        const gameBoardElement = document.getElementById('gameBoard');
        const nextPieceElement = document.getElementById('nextPiece');
        const currentPieceElement = document.getElementById('currentPiece');
        const floatingCurrentPieceElement = document.getElementById('floatingCurrentPiece');
        const scoreDisplayElement = document.getElementById('scoreDisplay');
        const levelDisplayElement = document.getElementById('levelDisplay');
        const progressBarElement = document.getElementById('progressBar');
        const rotateButtonElement = document.getElementById('rotateButton');
        const resetButtonElement = document.getElementById('resetButton');
        const gameOverModalElement = document.getElementById('gameOverModal');
        const finalScoreElement = document.getElementById('finalScore');
        const newGameButtonElement = document.getElementById('newGameButton');
        const shareScoreButtonElement = document.getElementById('shareScoreButton');

        // Initialize the game
        function initializeGame() {
            // Reset game state
            gameState = {
                board: Array(config.boardSize).fill().map(() => Array(config.boardSize).fill(0)),
                score: 0,
                level: 1,
                nextPieces: [],
                currentPiece: null,
                isGameOver: false,
                isDragging: false
            };
            
            // Initialize the board size
            gameBoardElement.style.setProperty('--columns', config.boardSize);
            gameBoardElement.style.setProperty('--rows', config.boardSize);
            
            // Generate initial blocks
            generateInitialPieces();
            
            // Initialize the game board
            renderGameBoard();
            
            // Render the next pieces
            renderNextPiece();
            renderCurrentPiece();
            
            // Update the score display
            updateScoreDisplay();
            
            // Hide game over modal if visible
            gameOverModalElement.classList.add('hidden');
        }

        // Generate initial pieces
        function generateInitialPieces() {
            gameState.nextPieces = [];
            
            for (let i = 0; i < config.initialBlocks; i++) {
                gameState.nextPieces.push(generateRandomPiece());
            }
            
            gameState.currentPiece = gameState.nextPieces.shift();
            gameState.nextPieces.push(generateRandomPiece());
        }

        // Generate a random game piece
        function generateRandomPiece() {
            // Select available shapes based on level
            let availableShapes = blockShapes.slice(0, 11); // Basic shapes for level 1
            
            if (gameState.level >= 2) {
                availableShapes.push(blockShapes[11]); // Plus shape
            }
            
            if (gameState.level >= 3) {
                availableShapes.push(blockShapes[12]); // U shape
            }
            
            if (gameState.level >= 5) {
                availableShapes.push(blockShapes[13]); // 3x3 square
            }
            
            // Select a random shape
            const shape = availableShapes[Math.floor(Math.random() * availableShapes.length)];
            
            // Select a random color
            const colorIndex = Math.floor(Math.random() * blockColors.length);
            
            return {
                shape: shape,
                colorIndex: colorIndex
            };
        }

        // Render the game board
        function renderGameBoard() {
            // Clear the game board
            gameBoardElement.innerHTML = '';
            
            // Create a cell for each position in the grid
            for (let row = 0; row < config.boardSize; row++) {
                for (let col = 0; col < config.boardSize; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    
                    // Set cell appearance based on board state
                    if (gameState.board[row][col] !== 0) {
                        const colorInfo = blockColors[gameState.board[row][col] - 1];
                        const color = isDarkMode() ? colorInfo.dark : colorInfo.light;
                        cell.style.backgroundColor = color;
                    } else {
                        cell.style.backgroundColor = isDarkMode() ? '#2D3748' : '#EDF2F7';
                    }
                    
                    // Add drop zone functionality
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('drop', handleDrop);
                    cell.addEventListener('click', handleCellClick);
                    
                    gameBoardElement.appendChild(cell);
                }
            }
        }

        // Render the next piece
        function renderNextPiece() {
            const piece = gameState.nextPieces[0];
            if (!piece) return;
            
            nextPieceElement.innerHTML = '';
            
            // Get dimensions for the piece container
            const rows = piece.shape.length;
            const cols = piece.shape[0].length;
            
            nextPieceElement.style.setProperty('--rows', rows);
            nextPieceElement.style.setProperty('--columns', cols);
            
            // Create a cell for each position in the piece
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('piece-cell');
                    
                    if (piece.shape[row][col] === 1) {
                        const colorInfo = blockColors[piece.colorIndex];
                        const color = isDarkMode() ? colorInfo.dark : colorInfo.light;
                        cell.style.backgroundColor = color;
                    } else {
                        cell.style.backgroundColor = 'transparent';
                    }
                    
                    nextPieceElement.appendChild(cell);
                }
            }
        }

        // Render the current piece for dragging
        function renderCurrentPiece() {
            if (!gameState.currentPiece) return;
            
            // Clear the current piece container
            currentPieceElement.innerHTML = '';
            floatingCurrentPieceElement.innerHTML = '';
            
            // Get dimensions for the piece container
            const rows = gameState.currentPiece.shape.length;
            const cols = gameState.currentPiece.shape[0].length;
            
            currentPieceElement.style.setProperty('--rows', rows);
            currentPieceElement.style.setProperty('--columns', cols);
            floatingCurrentPieceElement.style.setProperty('--rows', rows);
            floatingCurrentPieceElement.style.setProperty('--columns', cols);
            
            // Create a cell for each position in the piece
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // For the fixed current piece display
                    const cell = document.createElement('div');
                    cell.classList.add('piece-cell');
                    
                    if (gameState.currentPiece.shape[row][col] === 1) {
                        const colorInfo = blockColors[gameState.currentPiece.colorIndex];
                        const color = isDarkMode() ? colorInfo.dark : colorInfo.light;
                        cell.style.backgroundColor = color;
                    } else {
                        cell.style.backgroundColor = 'transparent';
                    }
                    
                    currentPieceElement.appendChild(cell);
                    
                    // For the floating piece that follows the cursor
                    const floatingCell = cell.cloneNode(true);
                    floatingCurrentPieceElement.appendChild(floatingCell);
                }
            }
            
            // Make the current piece draggable
            currentPieceElement.setAttribute('draggable', 'true');
            currentPieceElement.addEventListener('dragstart', handleDragStart);
            currentPieceElement.addEventListener('dragend', handleDragEnd);
            
            // Add special touch/mouse events for mobile
            currentPieceElement.addEventListener('pointerdown', handlePiecePointerDown);
        }

        // Update the score display
        function updateScoreDisplay() {
            scoreDisplayElement.textContent = gameState.score;
            levelDisplayElement.textContent = gameState.level;
            
            // Update the progress bar
            const progress = (gameState.score % config.levelUpThreshold) / config.levelUpThreshold * 100;
            progressBarElement.style.width = `${progress}%`;
        }

        // Rotate the current piece
        function rotateCurrentPiece() {
            if (!gameState.currentPiece) return;
            
            const oldShape = gameState.currentPiece.shape;
            const rows = oldShape.length;
            const cols = oldShape[0].length;
            
            // Create a new rotated shape
            const newShape = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    newShape[col][rows - 1 - row] = oldShape[row][col];
                }
            }
            
            gameState.currentPiece.shape = newShape;
            
            // Re-render the current piece
            renderCurrentPiece();
            
            // Play rotation sound
            playSound('rotate');
        }

        // Try to place the current piece on the board
        function tryPlacePiece(startRow, startCol) {
            if (!gameState.currentPiece) return false;
            
            const shape = gameState.currentPiece.shape;
            const rows = shape.length;
            const cols = shape[0].length;
            
            // Check if the piece fits on the board
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (shape[row][col] === 1) {
                        const boardRow = startRow + row;
                        const boardCol = startCol + col;
                        
                        // Check if within board boundaries
                        if (boardRow < 0 || boardRow >= config.boardSize || 
                            boardCol < 0 || boardCol >= config.boardSize) {
                            return false;
                        }
                        
                        // Check if the cell is already occupied
                        if (gameState.board[boardRow][boardCol] !== 0) {
                            return false;
                        }
                    }
                }
            }
            
            // Place the piece on the board
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (shape[row][col] === 1) {
                        const boardRow = startRow + row;
                        const boardCol = startCol + col;
                        
                        // Mark cell as occupied with the piece's color index
                        gameState.board[boardRow][boardCol] = gameState.currentPiece.colorIndex + 1;
                    }
                }
            }
            
            // Successfully placed the piece
            playSound('place');
            
            // Check for completed lines
            const clearedLines = checkForCompletedLines();
            
            if (clearedLines > 0) {
                // Calculate score based on lines cleared
                const baseScore = config.clearScoreBase * clearedLines;
                const multiplier = clearedLines === 1 ? 1 : Math.pow(config.multiplierBonus, clearedLines - 1);
                const scoreGained = baseScore * multiplier;
                
                gameState.score += scoreGained;
                
                // Check for level up
                const oldLevel = gameState.level;
                gameState.level = Math.min(config.maxLevel, 1 + Math.floor(gameState.score / config.levelUpThreshold));
                
                if (gameState.level > oldLevel) {
                    playSound('levelup');
                    
                    // Flash the level display
                    levelDisplayElement.classList.add('flash-animation');
                    setTimeout(() => {
                        levelDisplayElement.classList.remove('flash-animation');
                    }, 600);
                }
                
                // Update the score display
                updateScoreDisplay();
            }
            
            // Move to the next piece
            gameState.currentPiece = gameState.nextPieces.shift();
            
            // Generate a new piece for the queue
            gameState.nextPieces.push(generateRandomPiece());
            
            // Render the updated pieces
            renderNextPiece();
            renderCurrentPiece();
            
            // Check if the game is over (no valid moves for current piece)
            if (!checkForValidMoves()) {
                gameOver();
            }
            
            return true;
        }

        // Check for completed lines (rows and columns)
        function checkForCompletedLines() {
            const completedLines = [];
            
            // Check rows
            for (let row = 0; row < config.boardSize; row++) {
                let isComplete = true;
                for (let col = 0; col < config.boardSize; col++) {
                    if (gameState.board[row][col] === 0) {
                        isComplete = false;
                        break;
                    }
                }
                if (isComplete) {
                    completedLines.push({type: 'row', index: row});
                }
            }
            
            // Check columns
            for (let col = 0; col < config.boardSize; col++) {
                let isComplete = true;
                for (let row = 0; row < config.boardSize; row++) {
                    if (gameState.board[row][col] === 0) {
                        isComplete = false;
                        break;
                    }
                }
                if (isComplete) {
                    completedLines.push({type: 'column', index: col});
                }
            }
            
            // Clear completed lines
            if (completedLines.length > 0) {
                // First highlight them
                highlightCompletedLines(completedLines);
                
                // Then clear them with a slight delay for the visual effect
                setTimeout(() => {
                    clearCompletedLines(completedLines);
                    renderGameBoard();
                }, 300);
                
                // Play the appropriate sound
                if (completedLines.length > 2) {
                    playSound('multipleclear');
                } else {
                    playSound('clear');
                }
            }
            
            return completedLines.length;
        }

        // Highlight completed lines before clearing them with fancy effect and breaking animation
        function highlightCompletedLines(lines) {
            const cells = gameBoardElement.querySelectorAll('.cell');
            
            // Create a line glow overlay for the entire line
            lines.forEach(line => {
                if (line.type === 'row') {
                    // Add glow effect
                    const glowElement = document.createElement('div');
                    glowElement.classList.add('line-glow');
                    glowElement.style.position = 'absolute';
                    glowElement.style.left = '0';
                    glowElement.style.height = `calc(100% / ${config.boardSize})`;
                    glowElement.style.width = '100%';
                    glowElement.style.top = `calc(${line.index} * 100% / ${config.boardSize})`;
                    glowElement.style.zIndex = '15';
                    gameBoardElement.appendChild(glowElement);
                    
                    // Add clearing effect to cells and create sparkles
                    for (let col = 0; col < config.boardSize; col++) {
                        const index = line.index * config.boardSize + col;
                        const cell = cells[index];
                        
                        // Only process filled cells
                        if (gameState.board[line.index][col] === 0) continue;
                        
                        // Add the clearing class for break animation
                        cell.classList.add('clearing');
                        
                        // Get cell position and color for fragments
                        const cellRect = cell.getBoundingClientRect();
                        const boardRect = gameBoardElement.getBoundingClientRect();
                        const cellColor = cell.style.backgroundColor;
                        
                        // Create flying fragments
                        createBreakingFragments(cell, cellRect, boardRect, cellColor);
                        
                        // Create sparkles at random positions within this cell
                        for (let s = 0; s < 4; s++) {
                            setTimeout(() => {
                                if (document.body.contains(cell)) {
                                    const sparkle = document.createElement('div');
                                    sparkle.classList.add('sparkle');
                                    
                                    // Position relative to board
                                    const relativeLeft = (cellRect.left - boardRect.left) + 
                                                        Math.random() * cellRect.width;
                                    const relativeTop = (cellRect.top - boardRect.top) + 
                                                       Math.random() * cellRect.height;
                                    
                                    sparkle.style.left = `${relativeLeft}px`;
                                    sparkle.style.top = `${relativeTop}px`;
                                    
                                    // Random color based on the cell color
                                    const colors = ['#FFFFFF', '#FFEB3B', '#4CAF50', '#2196F3', '#9C27B0'];
                                    sparkle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                                    
                                    gameBoardElement.appendChild(sparkle);
                                    
                                    // Remove the sparkle after animation completes
                                    setTimeout(() => {
                                        if (document.body.contains(sparkle)) {
                                            sparkle.remove();
                                        }
                                    }, 700);
                                }
                            }, s * 80 + Math.random() * 200); // Stagger the sparkles
                        }
                    }
                } else { // column
                    // Add glow effect
                    const glowElement = document.createElement('div');
                    glowElement.classList.add('line-glow');
                    glowElement.style.position = 'absolute';
                    glowElement.style.top = '0';
                    glowElement.style.width = `calc(100% / ${config.boardSize})`;
                    glowElement.style.height = '100%';
                    glowElement.style.left = `calc(${line.index} * 100% / ${config.boardSize})`;
                    glowElement.style.zIndex = '15';
                    gameBoardElement.appendChild(glowElement);
                    
                    // Add clearing effect to cells and create sparkles
                    for (let row = 0; row < config.boardSize; row++) {
                        const index = row * config.boardSize + line.index;
                        const cell = cells[index];
                        
                        // Only process filled cells
                        if (gameState.board[row][line.index] === 0) continue;
                        
                        // Add the clearing class for break animation
                        cell.classList.add('clearing');
                        
                        // Get cell position and color for fragments
                        const cellRect = cell.getBoundingClientRect();
                        const boardRect = gameBoardElement.getBoundingClientRect();
                        const cellColor = cell.style.backgroundColor;
                        
                        // Create flying fragments
                        createBreakingFragments(cell, cellRect, boardRect, cellColor);
                        
                        // Create sparkles at random positions within this cell
                        for (let s = 0; s < 4; s++) {
                            setTimeout(() => {
                                if (document.body.contains(cell)) {
                                    const sparkle = document.createElement('div');
                                    sparkle.classList.add('sparkle');
                                    
                                    // Position relative to board
                                    const relativeLeft = (cellRect.left - boardRect.left) + 
                                                        Math.random() * cellRect.width;
                                    const relativeTop = (cellRect.top - boardRect.top) + 
                                                       Math.random() * cellRect.height;
                                    
                                    sparkle.style.left = `${relativeLeft}px`;
                                    sparkle.style.top = `${relativeTop}px`;
                                    
                                    // Random color based on the cell color
                                    const colors = ['#FFFFFF', '#FFEB3B', '#4CAF50', '#2196F3', '#9C27B0'];
                                    sparkle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                                    
                                    gameBoardElement.appendChild(sparkle);
                                    
                                    // Remove the sparkle after animation completes
                                    setTimeout(() => {
                                        if (document.body.contains(sparkle)) {
                                            sparkle.remove();
                                        }
                                    }, 700);
                                }
                            }, s * 80 + Math.random() * 200); // Stagger the sparkles
                        }
                    }
                }
                
                // Clean up glow elements after animation
                setTimeout(() => {
                    const glowElements = document.querySelectorAll('.line-glow');
                    glowElements.forEach(el => {
                        if (document.body.contains(el)) {
                            el.remove();
                        }
                    });
                }, 800);
            });
        }
        
        // Create flying fragments when blocks break
        function createBreakingFragments(cell, cellRect, boardRect, cellColor) {
            // Number of fragments to create
            const numFragments = 5 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < numFragments; i++) {
                setTimeout(() => {
                    if (!document.body.contains(cell)) return;
                    
                    // Create fragment element
                    const fragment = document.createElement('div');
                    fragment.classList.add('fragment');
                    
                    // Calculate size (smaller than the original cell)
                    const size = 4 + Math.random() * 6;
                    fragment.style.width = `${size}px`;
                    fragment.style.height = `${size}px`;
                    
                    // Set color to match the cell
                    fragment.style.backgroundColor = cellColor;
                    
                    // Position at a random point inside the cell
                    const relativeLeft = (cellRect.left - boardRect.left) + 
                                        (Math.random() * 0.7 + 0.15) * cellRect.width;
                    const relativeTop = (cellRect.top - boardRect.top) + 
                                       (Math.random() * 0.7 + 0.15) * cellRect.height;
                    
                    fragment.style.left = `${relativeLeft}px`;
                    fragment.style.top = `${relativeTop}px`;
                    
                    // Set random direction for the fragment to fly
                    const tx = (Math.random() - 0.5) * 100; // -50px to 50px
                    const ty = (Math.random() - 0.5) * 100; // -50px to 50px
                    const rotate = Math.random() * 720 - 360; // -360deg to 360deg
                    
                    fragment.style.setProperty('--tx', `${tx}px`);
                    fragment.style.setProperty('--ty', `${ty}px`);
                    fragment.style.setProperty('--rotate', `${rotate}deg`);
                    
                    // Add the fragment to the game board
                    gameBoardElement.appendChild(fragment);
                    
                    // Remove the fragment after animation completes
                    setTimeout(() => {
                        if (document.body.contains(fragment)) {
                            fragment.remove();
                        }
                    }, 600);
                }, i * 60); // Stagger the fragments for more natural effect
            }
        }

        // Clear completed lines and shift blocks
        function clearCompletedLines(lines) {
            lines.forEach(line => {
                if (line.type === 'row') {
                    // Clear the row
                    for (let col = 0; col < config.boardSize; col++) {
                        gameState.board[line.index][col] = 0;
                    }
                } else { // column
                    // Clear the column
                    for (let row = 0; row < config.boardSize; row++) {
                        gameState.board[row][line.index] = 0;
                    }
                }
            });
        }

        // Check if there are any valid moves for the current piece
        function checkForValidMoves() {
            if (!gameState.currentPiece) return false;
            
            const shape = gameState.currentPiece.shape;
            const rows = shape.length;
            const cols = shape[0].length;
            
            // Try to place the piece at every possible position
            for (let startRow = 0; startRow <= config.boardSize - rows; startRow++) {
                for (let startCol = 0; startCol <= config.boardSize - cols; startCol++) {
                    let canPlace = true;
                    
                    // Check if the piece can be placed here
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            if (shape[row][col] === 1) {
                                if (gameState.board[startRow + row][startCol + col] !== 0) {
                                    canPlace = false;
                                    break;
                                }
                            }
                        }
                        if (!canPlace) break;
                    }
                    
                    if (canPlace) return true;
                }
            }
            
            // Check all four rotations
            for (let rotation = 0; rotation < 3; rotation++) {
                // Rotate the piece
                const oldShape = gameState.currentPiece.shape;
                const shapeRows = oldShape.length;
                const shapeCols = oldShape[0].length;
                
                const newShape = Array(shapeCols).fill().map(() => Array(shapeRows).fill(0));
                
                for (let row = 0; row < shapeRows; row++) {
                    for (let col = 0; col < shapeCols; col++) {
                        newShape[col][shapeRows - 1 - row] = oldShape[row][col];
                    }
                }
                
                gameState.currentPiece.shape = newShape;
                
                // Check if this rotation can be placed
                if (checkForValidMoves()) {
                    return true;
                }
            }
            
            return false;
        }

        // Game over
        function gameOver() {
            gameState.isGameOver = true;
            finalScoreElement.textContent = gameState.score;
            gameOverModalElement.classList.remove('hidden');
            playSound('gameover');
        }

        // Event Handlers
        function handleDragStart(event) {
            if (gameState.isGameOver) return;
            
            gameState.isDragging = true;
            
            // Set data for drag operation
            event.dataTransfer.setData('text/plain', 'current-piece');
            
            // Set the drag image (optional)
            if (event.target.parentNode) {
                event.dataTransfer.setDragImage(event.target, 0, 0);
            }
            
            // Show the floating piece on desktop
            updateFloatingPiecePosition(event.clientX, event.clientY);
            floatingCurrentPieceElement.classList.remove('hidden');
            
            // Add dragging class to the source element
            event.target.classList.add('dragging');
        }

        function handleDragEnd(event) {
            gameState.isDragging = false;
            
            // Hide the floating piece
            floatingCurrentPieceElement.classList.add('hidden');
            
            // Remove dragging class
            event.target.classList.remove('dragging');
        }

        function handleDragOver(event) {
            if (gameState.isGameOver) return;
            
            // Allow the drop
            event.preventDefault();
            
            // Update the floating piece position if on desktop
            if (window.innerWidth >= 640) { // sm breakpoint
                updateFloatingPiecePosition(event.clientX, event.clientY);
            }
        }

        function handleDrop(event) {
            if (gameState.isGameOver) return;
            
            // Prevent default behavior
            event.preventDefault();
            
            // Get the row and column from the target cell
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            
            // Try to place the piece
            if (!isNaN(row) && !isNaN(col)) {
                // Calculate the top-left position to place the piece
                const shape = gameState.currentPiece.shape;
                const pieceRows = shape.length;
                const pieceCols = shape[0].length;
                
                const startRow = Math.max(0, Math.min(row - Math.floor(pieceRows / 2), config.boardSize - pieceRows));
                const startCol = Math.max(0, Math.min(col - Math.floor(pieceCols / 2), config.boardSize - pieceCols));
                
                // Try to place the piece
                const placed = tryPlacePiece(startRow, startCol);
                
                if (placed) {
                    renderGameBoard();
                } else {
                    // Show a visual cue that the piece can't be placed
                    gameBoardElement.classList.add('shake-animation');
                    setTimeout(() => {
                        gameBoardElement.classList.remove('shake-animation');
                    }, 300);
                    
                    playSound('invalid');
                }
            }
            
            // Hide the floating piece
            floatingCurrentPieceElement.classList.add('hidden');
        }
        
        // For mobile/touch devices
        function handlePiecePointerDown(event) {
            if (gameState.isGameOver) return;
            if (window.innerWidth >= 640) return; // Only for mobile
            
            // Prevent any default browser behaviors
            event.preventDefault();
            
            const touch = event.type.includes('touch') ? event.touches[0] : event;
            const piece = event.currentTarget;
            
            piece.classList.add('dragging');
            
            // Create a floating clone for better visual feedback
            const clone = piece.cloneNode(true);
            clone.id = 'dragClone';
            clone.style.position = 'fixed';
            clone.style.zIndex = '1000';
            clone.style.opacity = '0.8';
            clone.style.pointerEvents = 'none';
            document.body.appendChild(clone);
            
            // Track the offset where the user touched the piece
            const pieceRect = piece.getBoundingClientRect();
            const offsetX = touch.clientX - pieceRect.left;
            const offsetY = touch.clientY - pieceRect.top;
            
            // Initial positioning of the clone
            clone.style.left = `${pieceRect.left}px`;
            clone.style.top = `${pieceRect.top}px`;
            clone.style.width = `${pieceRect.width}px`;
            clone.style.height = `${pieceRect.height}px`;
            
            // Function to move the piece with the touch
            const movePiece = (e) => {
                const touchMove = e.type.includes('touch') ? e.touches[0] : e;
                clone.style.left = `${touchMove.clientX - offsetX}px`;
                clone.style.top = `${touchMove.clientY - offsetY}px`;
            };
            
            // Function to handle the drop
            const dropPiece = (e) => {
                piece.classList.remove('dragging');
                
                // Remove the clone
                if (document.getElementById('dragClone')) {
                    document.body.removeChild(clone);
                }
                
                // Find the cell under the touch point
                const touchEnd = e.type.includes('touch') ? e.changedTouches[0] : e;
                const elementsAtPoint = document.elementsFromPoint(touchEnd.clientX, touchEnd.clientY);
                
                let placedSuccessfully = false;
                
                for (const element of elementsAtPoint) {
                    if (element.classList.contains('cell')) {
                        // Get the row and column from the target cell
                        const row = parseInt(element.dataset.row);
                        const col = parseInt(element.dataset.col);
                        
                        // Try to place the piece
                        if (!isNaN(row) && !isNaN(col)) {
                            // Calculate the top-left position to place the piece
                            const shape = gameState.currentPiece.shape;
                            const pieceRows = shape.length;
                            const pieceCols = shape[0].length;
                            
                            const startRow = Math.max(0, Math.min(row - Math.floor(pieceRows / 2), config.boardSize - pieceRows));
                            const startCol = Math.max(0, Math.min(col - Math.floor(pieceCols / 2), config.boardSize - pieceCols));
                            
                            // Try to place the piece
                            const placed = tryPlacePiece(startRow, startCol);
                            
                            if (placed) {
                                renderGameBoard();
                                placedSuccessfully = true;
                            } else {
                                // Show a visual cue that the piece can't be placed
                                gameBoardElement.classList.add('shake-animation');
                                setTimeout(() => {
                                    gameBoardElement.classList.remove('shake-animation');
                                }, 300);
                                
                                playSound('invalid');
                            }
                            
                            break;
                        }
                    }
                }
                
                // If we didn't find a cell or placement failed, animate the piece back
                if (!placedSuccessfully) {
                    // Reset the current piece display
                    renderCurrentPiece();
                }
                
                // Clean up event listeners
                document.removeEventListener('touchmove', movePiece);
                document.removeEventListener('touchend', dropPiece);
                document.removeEventListener('mousemove', movePiece);
                document.removeEventListener('mouseup', dropPiece);
            };
            
            // Add event listeners for move and drop - cover both touch and mouse
            document.addEventListener('touchmove', movePiece, { passive: false });
            document.addEventListener('touchend', dropPiece);
            document.addEventListener('mousemove', movePiece);
            document.addEventListener('mouseup', dropPiece);
        }

        // For desktop, update the floating piece position as user moves mouse
        function updateFloatingPiecePosition(x, y) {
            floatingCurrentPieceElement.style.left = `${x - floatingCurrentPieceElement.offsetWidth / 2}px`;
            floatingCurrentPieceElement.style.top = `${y - floatingCurrentPieceElement.offsetHeight / 2}px`;
        }
        
        // For mobile/desktop click placement
        function handleCellClick(event) {
            if (gameState.isGameOver || gameState.isDragging) return;
            
            // This is a fallback for desktop when drag-and-drop isn't being used
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            
            // Try to place the piece
            if (!isNaN(row) && !isNaN(col)) {
                // Calculate the top-left position to place the piece
                const shape = gameState.currentPiece.shape;
                const pieceRows = shape.length;
                const pieceCols = shape[0].length;
                
                const startRow = Math.max(0, Math.min(row - Math.floor(pieceRows / 2), config.boardSize - pieceRows));
                const startCol = Math.max(0, Math.min(col - Math.floor(pieceCols / 2), config.boardSize - pieceCols));
                
                // Try to place the piece
                const placed = tryPlacePiece(startRow, startCol);
                
                if (placed) {
                    renderGameBoard();
                } else {
                    // Show a visual cue that the piece can't be placed
                    gameBoardElement.classList.add('shake-animation');
                    setTimeout(() => {
                        gameBoardElement.classList.remove('shake-animation');
                    }, 300);
                    
                    playSound('invalid');
                }
            }
        }

        // Handle mouse movement for the floating piece
        document.addEventListener('mousemove', (event) => {
            if (gameState.isDragging && window.innerWidth >= 640) { // sm breakpoint
                updateFloatingPiecePosition(event.clientX, event.clientY);
            }
        });

        // Sound effects (simple implementation)
        function playSound(type) {
            // Create audio context on demand
            if (!window.audioContext) {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    window.audioContext = new AudioContext();
                } catch (e) {
                    console.error('Web Audio API not supported.');
                    return;
                }
            }
            
            // Simple oscillator sounds
            const oscillator = window.audioContext.createOscillator();
            const gainNode = window.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(window.audioContext.destination);
            
            // Set sound parameters based on type
            switch(type) {
                case 'place':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 300;
                    gainNode.gain.value = 0.2;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(
                        500, window.audioContext.currentTime + 0.1
                    );
                    oscillator.stop(window.audioContext.currentTime + 0.1);
                    break;
                case 'rotate':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.15;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(
                        300, window.audioContext.currentTime + 0.15
                    );
                    oscillator.stop(window.audioContext.currentTime + 0.15);
                    break;
                case 'clear':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.2;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(
                        600, window.audioContext.currentTime + 0.2
                    );
                    oscillator.stop(window.audioContext.currentTime + 0.2);
                    break;
                case 'multipleclear':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.25;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(
                        800, window.audioContext.currentTime + 0.3
                    );
                    oscillator.stop(window.audioContext.currentTime + 0.3);
                    break;
                case 'invalid':
                    oscillator.type = 'square';
                    oscillator.frequency.value = 150;
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(window.audioContext.currentTime + 0.1);
                    break;
                case 'levelup':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.25;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(
                        800, window.audioContext.currentTime + 0.2
                    );
                    setTimeout(() => {
                        const oscTwo = window.audioContext.createOscillator();
                        oscTwo.connect(gainNode);
                        oscTwo.type = 'sine';
                        oscTwo.frequency.value = 900;
                        oscTwo.start();
                        oscTwo.frequency.exponentialRampToValueAtTime(
                            1200, window.audioContext.currentTime + 0.2
                        );
                        oscTwo.stop(window.audioContext.currentTime + 0.2);
                    }, 200);
                    oscillator.stop(window.audioContext.currentTime + 0.2);
                    break;
                case 'gameover':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.2;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(
                        100, window.audioContext.currentTime + 0.4
                    );
                    oscillator.stop(window.audioContext.currentTime + 0.4);
                    break;
            }
        }

        // Helper for dark mode detection
        function isDarkMode() {
            return document.documentElement.classList.contains('dark');
        }

        // Share score functionality
        function shareScore() {
            const message = `I scored ${gameState.score} points in Block Blast puzzle game! Level: ${gameState.level}`;
            
            // Try to use the Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: 'Block Blast Score',
                    text: message
                }).catch(err => {
                    console.error('Share failed:', err);
                    // Fallback to copy to clipboard
                    copyToClipboard(message);
                });
            } else {
                // Fallback to copy to clipboard
                copyToClipboard(message);
            }
        }

        // Copy to clipboard helper
        function copyToClipboard(text) {
            // Try to use the modern Clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        alert('Score copied to clipboard!');
                    })
                    .catch(() => {
                        console.error('Failed to copy to clipboard');
                    });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert('Score copied to clipboard!');
                } catch (err) {
                    console.error('Failed to copy to clipboard');
                }
                document.body.removeChild(textArea);
            }
        }

        // Add event listeners
        rotateButtonElement.addEventListener('click', rotateCurrentPiece);
        resetButtonElement.addEventListener('click', initializeGame);
        newGameButtonElement.addEventListener('click', initializeGame);
        shareScoreButtonElement.addEventListener('click', shareScore);

        // Mouse move for the floating current piece (desktop only)
        document.addEventListener('mousemove', (event) => {
            if (gameState.isDragging && window.innerWidth >= 640) {
                floatingCurrentPieceElement.style.left = `${event.clientX - 50}px`;
                floatingCurrentPieceElement.style.top = `${event.clientY - 50}px`;
            }
        });

        // Helper function to make element explicitly touchable
        function makeTouchDraggable(element) {
            if (!element) return;
            
            element.addEventListener('touchstart', function(e) {
                // This prevents the browser from scrolling during drag
                e.preventDefault();
                
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const rect = element.getBoundingClientRect();
                const offsetX = touchX - rect.left;
                const offsetY = touchY - rect.top;
                
                // Create a clone to drag
                const clone = element.cloneNode(true);
                clone.id = 'touchDragClone';
                clone.style.position = 'fixed';
                clone.style.left = `${rect.left}px`;
                clone.style.top = `${rect.top}px`;
                clone.style.width = `${rect.width}px`;
                clone.style.height = `${rect.height}px`;
                clone.style.zIndex = '1000';
                clone.style.opacity = '0.8';
                clone.style.pointerEvents = 'none';
                clone.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
                document.body.appendChild(clone);
                
                // Function to move the clone with touch
                function moveClone(e) {
                    e.preventDefault();
                    const moveX = e.touches[0].clientX;
                    const moveY = e.touches[0].clientY;
                    clone.style.left = `${moveX - offsetX}px`;
                    clone.style.top = `${moveY - offsetY}px`;
                }
                
                // Function to handle drop
                function dropClone(e) {
                    e.preventDefault();
                    
                    // Find drop target
                    const dropX = e.changedTouches[0].clientX;
                    const dropY = e.changedTouches[0].clientY;
                    const elements = document.elementsFromPoint(dropX, dropY);
                    
                    let placed = false;
                    
                    // Find if there's a cell at drop position
                    for (const el of elements) {
                        if (el.classList.contains('cell')) {
                            const row = parseInt(el.dataset.row);
                            const col = parseInt(el.dataset.col);
                            
                            if (!isNaN(row) && !isNaN(col)) {
                                // Calculate placement position
                                const shape = gameState.currentPiece.shape;
                                const pieceRows = shape.length;
                                const pieceCols = shape[0].length;
                                
                                const startRow = Math.max(0, Math.min(row - Math.floor(pieceRows / 2), config.boardSize - pieceRows));
                                const startCol = Math.max(0, Math.min(col - Math.floor(pieceCols / 2), config.boardSize - pieceCols));
                                
                                // Try to place the piece
                                placed = tryPlacePiece(startRow, startCol);
                                
                                if (placed) {
                                    renderGameBoard();
                                } else {
                                    // Visual feedback for invalid placement
                                    gameBoardElement.classList.add('shake-animation');
                                    setTimeout(() => {
                                        gameBoardElement.classList.remove('shake-animation');
                                    }, 300);
                                    playSound('invalid');
                                }
                                break;
                            }
                        }
                    }
                    
                    // Clean up
                    document.body.removeChild(clone);
                    document.removeEventListener('touchmove', moveClone);
                    document.removeEventListener('touchend', dropClone);
                }
                
                // Add event listeners
                document.addEventListener('touchmove', moveClone, { passive: false });
                document.addEventListener('touchend', dropClone, { passive: false });
            }, { passive: false });
        }
        
        // Override the render current piece to add explicit touch handling
        const originalRenderCurrentPiece = renderCurrentPiece;
        renderCurrentPiece = function() {
            originalRenderCurrentPiece();
            // Apply explicit touch handling
            if (currentPieceElement) {
                makeTouchDraggable(currentPieceElement);
            }
        };
        
        // Initialize the game when the page loads
        initializeGame();
    </script>


</body></html>
